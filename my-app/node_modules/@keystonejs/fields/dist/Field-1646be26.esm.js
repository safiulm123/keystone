import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import '@babel/runtime/helpers/esm/objectWithoutProperties';
import { countArrays, arrayToObject, captureSuspensePromises } from '@keystonejs/utils';
import { jsx } from '@emotion/core';
import { Component, Fragment, Suspense, useCallback, useMemo, useState } from 'react';
import { FieldContainer, FieldLabel, FieldInput } from '@arch-ui/fields';
import _extends from '@babel/runtime/helpers/esm/extends';
import '@arch-ui/select';
import { gridSize } from '@arch-ui/theme';
import _taggedTemplateLiteral from '@babel/runtime/helpers/esm/taggedTemplateLiteral';
import { Mutation, Query } from 'react-apollo';
import gql from 'graphql-tag';
import { PersonIcon, LinkExternalIcon, PlusIcon } from '@arch-ui/icons';
import { LoadingButton, Button, IconButton } from '@arch-ui/button';
import Tooltip from '@arch-ui/tooltip';
import Drawer from '@arch-ui/drawer';
import { AutocompleteCaptor } from '@arch-ui/input';
import { LoadingIndicator } from '@arch-ui/loading';
import 'react-select';
import 'intersection-observer';
import { R as RelationshipSelect } from './RelationshipSelect-31857caf.esm.js';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const PageLoading = () => jsx("div", {
  css: {
    height: 200,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: '100%'
  }
}, jsx(LoadingIndicator, {
  size: 12
}));

let Render = _ref => {
  let {
    children
  } = _ref;
  return children();
};

class CreateItemModal extends Component {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "onCreate", async event => {
      // prevent form submission
      event.preventDefault(); // we have to stop propagation so that if this modal is inside another form
      // it won't submit the form above it
      // this will most likely happen when a CreateItemModal is nested inside
      // another CreateItemModal when creating an item in a relationship field
      // if you're thinking, why is this necessary, the modal is in a portal?
      // it's important to remember that react events
      // propagate through portals as if they aren't there

      event.stopPropagation();
      const {
        list: {
          fields
        },
        createItem,
        isLoading
      } = this.props;
      if (isLoading) return;
      const {
        item,
        validationErrors,
        validationWarnings
      } = this.state;

      if (countArrays(validationErrors)) {
        return;
      }

      const creatable = fields.filter(_ref2 => {
        let {
          isPrimaryKey
        } = _ref2;
        return !isPrimaryKey;
      }).filter(_ref3 => {
        let {
          maybeAccess
        } = _ref3;
        return !!maybeAccess.create;
      });
      const data = arrayToObject(creatable, 'path', field => field.serialize(item));

      if (!countArrays(validationWarnings)) {
        const errors = {};
        const warnings = {};
        await Promise.all(fields.map(_ref4 => {
          let {
            validateInput,
            path
          } = _ref4;

          const addFieldValidationError = (message, data) => {
            errors[path] = errors[path] || [];
            errors[path].push({
              message,
              data
            });
          };

          const addFieldValidationWarning = (message, data) => {
            warnings[path] = warnings[path] || [];
            warnings[path].push({
              message,
              data
            });
          };

          return validateInput({
            resolvedData: data,
            originalInput: item,
            addFieldValidationError,
            addFieldValidationWarning
          });
        }));

        if (countArrays(errors) + countArrays(warnings) > 0) {
          this.setState(() => ({
            validationErrors: errors,
            validationWarnings: warnings
          }));
          return;
        }
      }

      createItem({
        variables: {
          data
        }
      }).then(data => {
        this.props.onCreate(data);
        this.setState({
          item: this.props.list.getInitialItemData({})
        });
      });
    });

    _defineProperty(this, "onClose", () => {
      const {
        isLoading
      } = this.props;
      if (isLoading) return;
      this.props.onClose();
    });

    _defineProperty(this, "onKeyDown", event => {
      if (event.defaultPrevented) return;

      switch (event.key) {
        case 'Escape':
          return this.onClose();
      }
    });

    _defineProperty(this, "formComponent", props => jsx("form", _extends({
      autoComplete: "off",
      onSubmit: this.onCreate
    }, props)));

    const {
      list,
      prefillData = {}
    } = _props;

    const _item = list.getInitialItemData({
      prefill: prefillData
    });

    const _validationErrors = {};
    const _validationWarnings = {};
    this.state = {
      item: _item,
      validationErrors: _validationErrors,
      validationWarnings: _validationWarnings
    };
  }

  render() {
    const {
      isLoading,
      isOpen,
      list
    } = this.props;
    const {
      item,
      validationErrors,
      validationWarnings
    } = this.state;
    const hasWarnings = countArrays(validationWarnings);
    const hasErrors = countArrays(validationErrors);
    const cypressId = 'create-relationship-item-modal-submit-button';
    return jsx(Drawer, {
      closeOnBlanketClick: true,
      component: this.formComponent,
      isOpen: isOpen,
      onClose: this.onClose,
      heading: "Create ".concat(list.singular),
      onKeyDown: this.onKeyDown,
      slideInFrom: "right",
      footer: jsx(Fragment, null, jsx(LoadingButton, {
        appearance: hasWarnings && !hasErrors ? 'warning' : 'primary',
        id: cypressId,
        isDisabled: hasErrors,
        isLoading: isLoading,
        onClick: this.onUpdate,
        type: "submit"
      }, hasWarnings && !hasErrors ? 'Ignore Warnings and Create' : 'Create'), jsx(Button, {
        appearance: "warning",
        variant: "subtle",
        onClick: this.onClose
      }, "Cancel"))
    }, jsx("div", {
      css: {
        marginBottom: gridSize,
        marginTop: gridSize
      }
    }, jsx(Suspense, {
      fallback: jsx(PageLoading, null)
    }, jsx(AutocompleteCaptor, null), jsx(Render, null, () => {
      const creatable = list.fields.filter(_ref5 => {
        let {
          isPrimaryKey
        } = _ref5;
        return !isPrimaryKey;
      }).filter(_ref6 => {
        let {
          maybeAccess
        } = _ref6;
        return !!maybeAccess.create;
      });
      captureSuspensePromises(creatable.map(field => () => field.initFieldView()));
      return creatable.map((field, i) => {
        return jsx(Render, {
          key: field.path
        }, () => {
          let [Field] = field.adminMeta.readViews([field.views.Field]);
          let onChange = useCallback(value => {
            this.setState(_ref7 => {
              let {
                item
              } = _ref7;
              return {
                item: _objectSpread({}, item, {
                  [field.path]: value
                }),
                validationErrors: {},
                validationWarnings: {}
              };
            });
          }, []);
          return useMemo(() => jsx(Field, {
            autoFocus: !i,
            value: item[field.path],
            savedValue: item[field.path],
            field: field
            /* TODO: Permission query results */
            ,
            errors: validationErrors[field.path] || [],
            warnings: validationWarnings[field.path] || [],
            onChange: onChange,
            renderContext: "dialog"
          }), [i, item[field.path], field, onChange, validationErrors[field.path], validationWarnings[field.path]]);
        });
      });
    }))));
  }

}

class CreateItemModalWithMutation extends Component {
  render() {
    const {
      list
    } = this.props;
    return jsx(Mutation, {
      mutation: list.createMutation
    }, (createItem, _ref8) => {
      let {
        loading
      } = _ref8;
      return jsx(CreateItemModal, _extends({
        createItem: createItem,
        isLoading: loading
      }, this.props));
    });
  }

}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n        query User {\n          ", " {\n            _label_\n            id\n          }\n        }\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

const MAX_IDS_IN_FILTER = 100;

function SetAsCurrentUser(_ref) {
  let {
    listKey,
    value,
    onAddUser,
    many
  } = _ref;
  let path = 'authenticated' + listKey;
  return jsx(Query, {
    query: gql(_templateObject(), path)
  }, _ref2 => {
    let {
      data
    } = _ref2;

    if (data && data[path]) {
      let userId = data[path].id;

      if (value !== null && (many ? value.some(item => item.id === userId) : value.id === userId)) {
        return null;
      }

      let label = "".concat(many ? 'Add' : 'Set as', " ").concat(data[path]._label_);
      return jsx(Tooltip, {
        placement: "top",
        content: label
      }, ref => jsx(IconButton, {
        css: {
          marginLeft: gridSize
        },
        variant: "ghost",
        ref: ref,
        onClick: () => {
          onAddUser(data[path]);
        },
        icon: PersonIcon,
        "aria-label": label
      }));
    }

    return null;
  });
}

function LinkToRelatedItems(_ref3) {
  let {
    field,
    value
  } = _ref3;
  const {
    many,
    ref
  } = field.config;
  const {
    adminPath,
    getListByKey
  } = field.adminMeta;
  const refList = getListByKey(ref);
  let isDisabled = false;
  let label;
  let link = "".concat(adminPath, "/").concat(refList.path);

  if (many) {
    label = 'View List of Related Items';

    if (!value.length) {
      isDisabled = true;
    } // What happens when there are 10,000 ids? The URL would be too
    // big, so we arbitrarily limit it to the first 100


    link = "".concat(link, "?!id_in=\"").concat(value.slice(0, MAX_IDS_IN_FILTER).map(_ref4 => {
      let {
        id
      } = _ref4;
      return id;
    }).join(','), "\"");
  } else {
    label = 'View Item Details';

    if (!value) {
      isDisabled = true;
    } else {
      link = "".concat(link, "/").concat(value.id);
    }
  }

  return jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => jsx(IconButton, {
    ref: ref,
    icon: LinkExternalIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: gridSize
    },
    target: "_blank",
    to: link,
    isDisabled: isDisabled
  }));
}

function CreateAndAddItem(_ref5) {
  let {
    field,
    item,
    list,
    onCreate: _onCreate
  } = _ref5;
  let relatedList = field.adminMeta.getListByKey(field.config.ref);
  let [isOpen, setIsOpen] = useState(false);
  let label = "Create and add ".concat(relatedList.singular);
  let prefillData;

  if (item && item.id) {
    prefillData = relatedList.fields // Find relationships on the refList which have a back link to this
    // Relationship field
    .filter(relatedField => relatedField.type === 'Relationship' && relatedField.config.ref === list.key && relatedField.config.refFieldPath === field.path) // And convert it into an object of data to prefill the form with
    .reduce((memo, prefillField) => {
      const prefill = {
        _label_: item._label_ || '<link to parent>',
        id: item.id
      };
      return _objectSpread$1({}, memo, {
        [prefillField.path]: prefillField.config.many ? [prefill] : prefill
      });
    }, {});
  }

  return jsx(Fragment, null, jsx(Tooltip, {
    placement: "top",
    content: label
  }, ref => jsx(IconButton, {
    ref: ref,
    onClick: () => {
      setIsOpen(true);
    },
    icon: PlusIcon,
    "aria-label": label,
    variant: "ghost",
    css: {
      marginLeft: gridSize
    }
  })), jsx(CreateItemModalWithMutation, {
    isOpen: isOpen,
    list: relatedList,
    prefillData: prefillData,
    onClose: () => {
      setIsOpen(false);
    },
    onCreate: _ref6 => {
      let {
        data
      } = _ref6;
      setIsOpen(false);
      console.log(data);

      _onCreate(data[relatedList.gqlNames.createMutationName]);
    }
  }));
}

class RelationshipField extends Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onChange", option => {
      const {
        field,
        onChange
      } = this.props;
      const {
        many
      } = field.config;

      if (many) {
        onChange(option.map(i => i.value));
      } else {
        onChange(option ? option.value : null);
      }
    });
  }

  render() {
    const {
      autoFocus,
      field,
      value,
      renderContext,
      errors,
      onChange,
      item,
      list
    } = this.props;
    const {
      many,
      ref
    } = field.config;
    const {
      authStrategy
    } = field.adminMeta;
    const htmlID = "ks-input-".concat(field.path);
    return jsx(FieldContainer, null, jsx(FieldLabel, {
      htmlFor: htmlID,
      field: field,
      errors: errors
    }), jsx(FieldInput, null, jsx("div", {
      css: {
        flex: 1
      }
    }, jsx(RelationshipSelect, {
      autoFocus: autoFocus,
      isMulti: many,
      field: field,
      value: value,
      errors: errors,
      renderContext: renderContext,
      htmlID: htmlID,
      onChange: this.onChange
    })), jsx(CreateAndAddItem, {
      onCreate: item => {
        onChange(many ? (value || []).concat(item) : item);
      },
      field: field,
      item: item,
      list: list
    }), authStrategy && ref === authStrategy.listKey && jsx(SetAsCurrentUser, {
      many: many,
      onAddUser: user => {
        onChange(many ? (value || []).concat(user) : user);
      },
      value: value,
      listKey: authStrategy.listKey
    }), jsx(LinkToRelatedItems, {
      field: field,
      value: value
    })));
  }

}

export default RelationshipField;
