"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _slicedToArray = _interopDefault(require("@babel/runtime/helpers/slicedToArray")), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), core = require("@emotion/core"), styled = _interopDefault(require("@emotion/styled")), dateFns = require("date-fns"), reactWindow = require("react-window"), icons = require("@arch-ui/icons"), React = require("react"), theme = require("@arch-ui/theme"), typography = require("@arch-ui/typography");

require("intersection-observer");

var input = require("@arch-ui/input"), Select = _interopDefault(require("@arch-ui/select")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), chrono = _interopDefault(require("chrono-node")), moment = _interopDefault(require("moment"));

const yearRange = (from, to) => {
  const years = [];
  let year = from;
  for (;year <= to; ) years.push(year++);
  return years;
}, months = Array.from({
  length: 12
}, (_, i) => i);

function createDayObject(dateValue) {
  return {
    dateValue: dateValue,
    label: dateFns.getDate(dateValue)
  };
}

function getWeeksInMonth(date) {
  const weekOptions = {
    weekStartsOn: 0
  }, firstDayOfMonth = dateFns.startOfMonth(date), firstDayOfFirstWeek = dateFns.startOfWeek(firstDayOfMonth, weekOptions), lastDayOfFirstWeek = dateFns.endOfWeek(firstDayOfMonth, weekOptions), getWeeks = (startDay, endDay, weekArray) => {
    const weeks = [ ...weekArray, dateFns.eachDay(startDay, endDay).map(createDayObject) ], nextWeek = dateFns.addWeeks(startDay, 1), firstDayNextWeek = dateFns.startOfWeek(nextWeek, weekOptions), lastDayNextWeek = dateFns.endOfWeek(nextWeek, weekOptions);
    return dateFns.isSameMonth(firstDayNextWeek, date) ? getWeeks(firstDayNextWeek, lastDayNextWeek, weeks) : weeks;
  };
  return getWeeks(firstDayOfFirstWeek, lastDayOfFirstWeek, []);
}

function isNumberInRange(num, start, end) {
  return num >= start && num <= end;
}

function usePrevious(value) {
  const ref = React.useRef(value);
  return React.useEffect(() => {
    ref.current = value;
  }), ref.current;
}

const monthOptions = months.map((month, i) => core.jsx("option", {
  key: i,
  value: i
}, dateFns.format(dateFns.setMonth(new Date(), month), "MMM"))), SelectMonth = React.memo(_ref => {
  let _onChange = _ref.onChange, month = _ref.month;
  return core.jsx("select", {
    id: "ks-select-month",
    onChange: event => {
      _onChange(Number(event.target.value));
    },
    value: month
  }, monthOptions);
}), SelectYear = React.memo(_ref2 => {
  let onChange = _ref2.onChange, year = _ref2.year, yearRangeFrom = _ref2.yearRangeFrom, yearRangeTo = _ref2.yearRangeTo, yearPickerType = _ref2.yearPickerType;
  const years = yearRange(yearRangeFrom, yearRangeTo), _useState = React.useState(year), _useState2 = _slicedToArray(_useState, 2), internalValue = _useState2[0], setInternalValue = _useState2[1], previousYearProp = usePrevious(year);
  React.useEffect(() => {
    previousYearProp !== year && setInternalValue(year);
  }, [ previousYearProp, year, setInternalValue ]);
  const handleChange = event => {
    const value = Number(event.target.value);
    setInternalValue(value), isNumberInRange(value, yearRangeFrom, yearRangeTo) && onChange(value);
  };
  return years.length > 50 && "auto" === yearPickerType || "input" === yearPickerType ? core.jsx("input", {
    id: "ks-input-year",
    type: "number",
    min: yearRangeFrom,
    max: yearRangeTo,
    onChange: handleChange,
    value: internalValue
  }) : core.jsx("select", {
    id: "ks-select-year",
    onChange: handleChange,
    value: internalValue
  }, years.map((yearOption, i) => core.jsx("option", {
    key: i,
    value: yearOption
  }, yearOption)));
}), WeekRow = styled.div({
  display: "flex"
}), WeekLabels = styled(WeekRow)({
  color: theme.colors.N40,
  fontSize: "0.65rem",
  fontWeight: 500,
  textTransform: "uppercase"
}), Day = styled.div(_ref => {
  let textColor, disabled = _ref.disabled, isInteractive = _ref.isInteractive, isSelected = _ref.isSelected, isToday = _ref.isToday;
  return isToday && (textColor = theme.colors.danger), disabled && (textColor = theme.colors.N40), 
  isSelected && (textColor = "white"), {
    alignItems: "center",
    backgroundColor: isSelected ? theme.colors.primary : null,
    borderRadius: theme.borderRadius,
    color: textColor,
    cursor: isInteractive ? "pointer" : "default",
    display: "flex",
    flexDirection: "column",
    fontWeight: isSelected || isToday ? "bold" : null,
    flexBasis: "calc(100% / 7)",
    padding: "0.5rem",
    textAlign: "center",
    width: "calc(100% / 7)",
    ":hover": {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L90 : null,
      color: !isInteractive || isSelected || isToday ? null : theme.colors.B.D40
    },
    ":active": {
      backgroundColor: isInteractive && !isSelected ? theme.colors.B.L80 : null
    }
  };
}), TodayMarker = styled.div(_ref => {
  return {
    backgroundColor: _ref.isSelected ? "white" : theme.colors.danger,
    borderRadius: 4,
    height: 2,
    marginBottom: -4,
    marginTop: 2,
    width: "1em"
  };
}), Month = React.memo(_ref2 => {
  let style = _ref2.style, index = _ref2.index, data = _ref2.data;
  const items = data.items, selectedDate = data.selectedDate, onSelectedChange = data.onSelectedChange, observer = data.observer, ref = React.useRef(null);
  React.useEffect(() => {
    const node = ref.current;
    if (null !== node) return observer.observe(node), () => observer.unobserve(node);
  }, [ observer ]);
  const _items$index = items[index], weeks = _items$index.weeks, month = _items$index.month, year = _items$index.year;
  return core.jsx("div", {
    ref: ref,
    "data-index": index,
    id: "ks-month-".concat(month, "-").concat(year),
    style: style
  }, core.jsx(MonthHeader, {
    month: month,
    year: year
  }), weeks.map((week, i) => core.jsx(WeekRow, {
    key: i
  }, week.map(day => {
    const date = new Date(year, month, 3), disabled = !dateFns.isSameMonth(date, day.dateValue), isSelected = !disabled && null !== selectedDate && dateFns.isEqual(selectedDate, day.dateValue), isToday = dateFns.isToday(day.dateValue);
    return core.jsx(Day, {
      id: "ks-day-".concat(day.label, "-").concat(month, "-").concat(year),
      key: day.label,
      disabled: disabled,
      onClick: disabled ? null : () => onSelectedChange(day.dateValue),
      isInteractive: !disabled,
      isSelected: isSelected,
      isToday: isToday
    }, day.label, isToday ? core.jsx(TodayMarker, {
      isSelected: isSelected
    }) : null);
  }))));
});

let readableMonths = months.map(month => dateFns.format(dateFns.setMonth(new Date(), month), "MMMM"));

const MonthHeader = React.memo(_ref3 => {
  let month = _ref3.month, year = _ref3.year;
  return core.jsx("div", {
    css: {
      position: "sticky",
      top: 0,
      width: "100%",
      backgroundColor: "#fff"
    }
  }, core.jsx("div", {
    css: {
      paddingTop: 4,
      paddingBottom: 4,
      border: "1px ".concat(theme.colors.N60, " solid"),
      borderLeft: 0,
      borderRight: 0,
      display: "flex",
      justifyContent: "space-between",
      paddingRight: 12
    }
  }, core.jsx("span", {
    css: {
      color: theme.colors.N60
    }
  }, readableMonths[month]), core.jsx("span", {
    css: {
      color: theme.colors.N60
    }
  }, year)));
}), Wrapper = styled.div({
  fontSize: "0.85rem"
}), Header = styled.div({
  alignItems: "center",
  display: "flex",
  justifyContent: "space-between"
}), HeaderButton = props => core.jsx("button", _extends({
  type: "button",
  css: {
    background: "none",
    borderRadius: theme.borderRadius,
    border: "none",
    cursor: "pointer",
    padding: "0.5rem 0.75rem",
    outline: "none",
    ":hover": {
      backgroundColor: theme.colors.N05
    },
    ":active": {
      backgroundColor: theme.colors.N10
    }
  }
}, props));

let DAY_HEIGHT = 32.5;

function scrollToDate(date, yearRangeFrom, yearRangeTo, list) {
  if (null !== list) {
    const index = 12 * (dateFns.getYear(date) - yearRangeFrom) + date.getMonth();
    list.scrollToItem(index, "start");
  }
}

let weekLabels = core.jsx(WeekLabels, null, [ ...new Array(7) ].map((_, day) => dateFns.format(dateFns.setDay(new Date(), day), "ddd")).map(d => core.jsx(Day, {
  key: d
}, d)));

const DayPicker = _ref => {
  let yearRangeFrom = _ref.yearRangeFrom, yearRangeTo = _ref.yearRangeTo, yearPickerType = _ref.yearPickerType, startCurrentDateAt = _ref.startCurrentDateAt, selectedDate = _ref.selectedDate, onSelectedChange = _ref.onSelectedChange;
  const listRef = React.useRef(null);
  if (!isNumberInRange(startCurrentDateAt.getFullYear(), yearRangeFrom, yearRangeTo)) {
    let date = new Date();
    date.setFullYear(yearRangeTo), startCurrentDateAt = dateFns.endOfYear(date);
  }
  const _useState = React.useState(startCurrentDateAt), _useState2 = _slicedToArray(_useState, 2), date = _useState2[0], setDate = _useState2[1], shouldChangeScrollPositionRef = React.useRef(!0), controlledSetDate = React.useCallback(newDate => {
    shouldChangeScrollPositionRef.current = !0, setDate(newDate);
  }, [ shouldChangeScrollPositionRef, setDate ]);
  React.useLayoutEffect(() => {
    shouldChangeScrollPositionRef.current && (scrollToDate(date, yearRangeFrom, yearRangeTo, listRef.current), 
    shouldChangeScrollPositionRef.current = !1);
  }, [ date, yearRangeFrom, yearRangeTo, listRef ]);
  const years = React.useMemo(() => yearRange(yearRangeFrom, yearRangeTo), [ yearRangeFrom, yearRangeTo ]), items = React.useMemo(() => {
    const _items = [];
    return years.forEach(year => {
      months.forEach(month => {
        _items.push({
          year: year,
          month: month,
          weeks: getWeeksInMonth(new Date(year, month, 1))
        });
      });
    }), _items;
  }, [ years ]), currentIndex = 12 * (date.getFullYear() - yearRangeFrom) + date.getMonth(), canGoNextMonth = currentIndex < items.length - 1, canGoPreviousMonth = currentIndex > 0, observer = React.useMemo(() => new IntersectionObserver(entries => {
    const filteredEntries = entries.filter(value => value.isIntersecting).sort((a, b) => a.intersectionRatio > b.intersectionRatio ? -1 : 1);
    if (0 !== filteredEntries.length) {
      let index = Number(filteredEntries[0].target.getAttribute("data-index")), item = items[index];
      setDate(new Date(item.year, item.month, 1));
    }
  }, {
    threshold: .6
  }), [ items ]);
  return core.jsx(Wrapper, null, core.jsx(Header, null, React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoPreviousMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.subMonths(currentDate, 1));
    }
  }, core.jsx(icons.ChevronLeftIcon, null), core.jsx(typography.A11yText, null, "Previous Month")), [ controlledSetDate, canGoPreviousMonth ]), core.jsx(SelectMonth, {
    onChange: React.useCallback(month => {
      controlledSetDate(currentDate => dateFns.setMonth(currentDate, month));
    }, [ controlledSetDate ]),
    month: date.getMonth()
  }), core.jsx(SelectYear, {
    year: dateFns.getYear(date),
    onChange: React.useCallback(year => {
      controlledSetDate(currentDate => dateFns.setYear(currentDate, year));
    }, [ controlledSetDate ]),
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType
  }), React.useMemo(() => core.jsx(HeaderButton, {
    disabled: !canGoNextMonth,
    onClick: () => {
      controlledSetDate(currentDate => dateFns.addMonths(currentDate, 1));
    }
  }, core.jsx(icons.ChevronRightIcon, null), core.jsx(typography.A11yText, null, "Next Month")), [ controlledSetDate, canGoNextMonth ])), core.jsx("div", null, weekLabels, core.jsx(reactWindow.VariableSizeList, {
    ref: listRef,
    itemSize: React.useCallback(index => {
      return items[index].weeks.length * DAY_HEIGHT + 26.5;
    }, [ items ]),
    itemData: React.useMemo(() => ({
      items: items,
      selectedDate: selectedDate,
      onSelectedChange: onSelectedChange,
      observer: observer
    }), [ items, selectedDate, onSelectedChange, observer ]),
    height: 6 * DAY_HEIGHT + 26.5,
    itemCount: 12 * years.length,
    width: "100%"
  }, Month)));
};

DayPicker.defaultProps = {
  yearRangeFrom: dateFns.getYear(new Date()) - 100,
  yearRangeTo: dateFns.getYear(new Date()),
  yearPickerType: "auto"
};

const options = [ "-12", "-11", "-10", "-09", "-08", "-07", "-06", "-05", "-04", "-03", "-02", "-01", "+00", "+01", "+02", "+03", "+04", "+05", "+06", "+07", "+08", "+09", "+10", "+11", "+12", "+13", "+14" ].map(o => ({
  value: "".concat(o, ":00"),
  label: "".concat(o, ":00")
})), DayTimePicker = props => {
  const date = props.date, time = props.time, offset = props.offset, htmlID = props.htmlID, autoFocus = props.autoFocus, isDisabled = props.isDisabled, handleDayChange = props.handleDayChange, handleTimeChange = props.handleTimeChange, handleOffsetChange = props.handleOffsetChange, yearRangeFrom = props.yearRangeFrom, yearRangeTo = props.yearRangeTo, yearPickerType = props.yearPickerType, TODAY = new Date();
  return React.createElement("div", {
    id: htmlID
  }, React.createElement(DayPicker, {
    autoFocus: autoFocus,
    onSelectedChange: handleDayChange,
    yearRangeFrom: yearRangeFrom,
    yearRangeTo: yearRangeTo,
    yearPickerType: yearPickerType,
    startCurrentDateAt: date ? dateFns.parse(date) : TODAY,
    selectedDate: date ? dateFns.parse(date) : null
  }), React.createElement(input.Input, {
    type: "time",
    name: "time-picker",
    value: time,
    onChange: handleTimeChange,
    disabled: isDisabled || !1,
    id: "".concat(htmlID, "-time")
  }), React.createElement(Select, {
    value: options.find(option => option.value === offset),
    options: options,
    onChange: _ref => {
      let value = _ref.value;
      handleOffsetChange(value);
    },
    id: "".concat(htmlID, "-offset")
  }));
};

let TextDayPicker = _ref => {
  let date = _ref.date, onChange = _ref.onChange, props = _objectWithoutProperties(_ref, [ "date", "onChange" ]), _useState = React.useState(formatDate(date)), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
  return React.useEffect(() => {
    setValue(formatDate(date));
  }, [ date ]), core.jsx(input.Input, _extends({
    value: value,
    placeholder: "Enter a date...",
    onBlur: () => {
      let newDate = parseDate(value);
      onChange(newDate), setValue(formatDate(newDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function formatDate(date) {
  return null === date ? "" : dateFns.format(date, "Do MMMM YYYY");
}

function parseDate(value) {
  let parsedDates = chrono.parse(value);
  return void 0 === parsedDates[0] ? null : dateFns.format(parsedDates[0].start.date(), "YYYY-MM-DD");
}

let TextDayTimePicker = _ref => {
  let date = _ref.date, onChange = _ref.onChange, props = _objectWithoutProperties(_ref, [ "date", "onChange" ]), _useState = React.useState(""), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1], ref = React.useRef(null);
  return React.useEffect(() => {
    setValue(formatDateTime(date));
  }, [ date ]), core.jsx(input.Input, _extends({
    value: value,
    ref: ref,
    placeholder: "Enter a date and time...",
    onBlur: () => {
      let parsedDate = parseDate$1(value);
      onChange(parsedDate), setValue(formatDateTime(parsedDate));
    },
    onChange: event => {
      setValue(event.target.value);
    }
  }, props));
};

function formatDateTime(date) {
  return date ? moment.parseZone(date).format("h:mm A Do MMMM YYYY Z") : "";
}

function parseDate$1(value) {
  let _chrono$parse = chrono.parse(value), parsedDate = _slicedToArray(_chrono$parse, 1)[0];
  return void 0 === parsedDate ? null : parsedDateToMoment(parsedDate).toISOString(!0);
}

function parsedDateToMoment(parsedDate) {
  let dateMoment = moment(), currentTimezoneOffset = moment().utcOffset(), start = parsedDate.start;
  dateMoment.set("year", start.get("year")), dateMoment.set("month", start.get("month") - 1), 
  dateMoment.set("date", start.get("day")), dateMoment.set("hour", start.get("hour")), 
  dateMoment.set("minute", start.get("minute")), dateMoment.set("second", start.get("second")), 
  dateMoment.set("millisecond", start.get("millisecond"));
  let targetTimezoneOffset = void 0 !== start.get("timezoneOffset") ? start.get("timezoneOffset") : currentTimezoneOffset;
  return dateMoment.utcOffset(targetTimezoneOffset, !0), dateMoment;
}

exports.DayPicker = DayPicker, exports.DayTimePicker = DayTimePicker, exports.TextDayPicker = TextDayPicker, 
exports.TextDayTimePicker = TextDayTimePicker;
