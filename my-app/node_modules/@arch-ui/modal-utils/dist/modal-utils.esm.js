import _objectSpread from '@babel/runtime/helpers/esm/objectSpread';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import React, { memo, Component, Fragment } from 'react';
import { TransitionGroup, Transition } from 'react-transition-group';
import { jsx } from '@emotion/core';
import { colors } from '@arch-ui/theme';
import { alpha } from '@arch-ui/color-utils';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import ScrollLock from 'react-scrolllock';

const transitionDurationMs = 220;
const transitionDuration = "".concat(transitionDurationMs, "ms");
const transitionTimingFunction = 'cubic-bezier(0.2, 0, 0, 1)'; // ==============================
// Lifecycle Provider
// ==============================

const TransitionProvider = (_ref) => {
  let children = _ref.children,
      isOpen = _ref.isOpen,
      props = _objectWithoutProperties(_ref, ["children", "isOpen"]);

  return React.createElement(TransitionGroup, {
    component: null
  }, isOpen ? React.createElement(Transition, _extends({
    appear: true,
    mountOnEnter: true,
    unmountOnExit: true,
    timeout: transitionDurationMs
  }, props), state => children(state)) : null);
};
const withTransitionState = Comp => (_ref2) => {
  let isOpen = _ref2.isOpen,
      props = _objectWithoutProperties(_ref2, ["isOpen"]);

  return React.createElement(TransitionProvider, {
    isOpen: isOpen
  }, state => React.createElement(Comp, _extends({
    transitionState: state
  }, props)));
}; // ==============================
// Transitions
// ==============================

function makeTransitionBase(transitionProperty) {
  return {
    transitionProperty,
    transitionDuration,
    transitionTimingFunction
  };
}

const fade = transitionState => _objectSpread({}, makeTransitionBase('opacity'), {
  opacity: {
    entering: 1,
    entered: 1,
    exiting: 0,
    exited: 0
  }[transitionState]
}); // Slide Up
// ------------------------------

const slideUp = transitionState => {
  const out = {
    opacity: 0,
    transform: 'scale(0.95) translate3d(0,20px,0)'
  };
  return _objectSpread({}, makeTransitionBase('opacity, transform'), {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
};
const slideDown = function slideDown(transitionState) {
  let _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$from = _ref3.from,
      from = _ref3$from === void 0 ? '-8px' : _ref3$from;

  const out = {
    opacity: 0,
    transform: "translate3d(0,".concat(from, ",0)")
  };
  return _objectSpread({}, makeTransitionBase('opacity, transform'), {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    },
    exiting: out,
    exited: out
  }[transitionState]);
};
const fromMap = {
  left: '-100%',
  right: '100%'
}; // NOTE: should be able to use $Keys<typeof fromMap>

const slideInHorizontal = (transitionState, _ref4) => {
  let slideInFrom = _ref4.slideInFrom;
  const initial = fromMap[slideInFrom];
  return _objectSpread({}, makeTransitionBase('transform'), {
    entering: {
      transform: 'translate3d(0,0,0)'
    },
    entered: {
      transform: 'translate3d(0,0,0)'
    },
    exiting: {
      transform: "translate3d(".concat(initial, ", 0, 0)")
    },
    exited: {
      transform: "translate3d(".concat(initial, ", 0, 0)")
    }
  }[transitionState]);
};
const zoomInDown = transitionState => {
  return _objectSpread({
    transformOrigin: 'top',
    transitionProperty: 'opacity, transform',
    transitionDuration,
    transitionTimingFunction
  }, {
    entering: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    entered: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    exiting: {
      opacity: 0,
      transform: 'scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)'
    },
    exited: {
      opacity: 0,
      transform: 'scale3d(0.33, 0.33, 0.33) translate3d(0, -100%, 0)'
    }
  }[transitionState]);
};
const springDown = transitionState => {
  return _objectSpread({
    transformOrigin: 'top',
    transitionProperty: 'opacity, transform',
    transitionDuration,
    transitionTimingFunction: 'cubic-bezier(0.2, 0, 0.16, 1.6)'
  }, {
    entering: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    entered: {
      opacity: 1,
      transform: 'translate3d(0, 0, 0)'
    },
    exiting: {
      opacity: 0,
      transform: 'scale(0.93) translate3d(0, -12px, 0)'
    },
    exited: {
      opacity: 0,
      transform: 'scale(0.93) translate3d(0, -12px, 0)'
    }
  }[transitionState]);
};

const Blanket = (_ref) => {
  let isTinted = _ref.isTinted,
      isLight = _ref.isLight,
      props = _objectWithoutProperties(_ref, ["isTinted", "isLight"]);

  let bg = 'transparent';

  if (isTinted) {
    bg = isLight ? 'rgba(255, 255, 255, 0.5)' : alpha(colors.N100, 0.2);
  }

  return jsx("div", _extends({
    css: {
      backgroundColor: bg,
      bottom: 0,
      left: 0,
      position: 'fixed',
      right: 0,
      top: 0,
      zIndex: 2
    }
  }, props));
};

function getDisplayName(C) {
  return "withModalHandlers(".concat(C.displayName || C.name || 'Component', ")");
}

const NOOP = () => {};

let Target = memo(function Target(_ref) {
  let isOpen = _ref.isOpen,
      mode = _ref.mode,
      target = _ref.target,
      targetRef = _ref.targetRef,
      open = _ref.open,
      toggle = _ref.toggle;
  const cloneProps = {
    isActive: isOpen,
    ref: targetRef
  };
  if (mode === 'click') cloneProps.onClick = toggle;
  if (mode === 'contextmenu') cloneProps.onContextMenu = open;
  return target(cloneProps);
});
function withModalHandlers(WrappedComponent, _ref2) {
  let transition = _ref2.transition;

  class IntermediateComponent extends Component {
    constructor() {
      super(...arguments);

      _defineProperty(this, "lastHover", void 0);

      _defineProperty(this, "contentNode", void 0);

      _defineProperty(this, "targetNode", void 0);

      _defineProperty(this, "state", {
        isOpen: this.props.defaultIsOpen,
        clientX: 0,
        clientY: 0
      });

      _defineProperty(this, "open", event => {
        if (event.defaultPrevented) return;
        if (this.props.mode === 'contextmenu') event.preventDefault();
        const clientX = event.clientX,
              clientY = event.clientY;
        this.setState({
          isOpen: true,
          clientX,
          clientY
        });
        document.addEventListener('mousedown', this.handleMouseDown);
        document.addEventListener('keydown', this.handleKeyDown, false);
      });

      _defineProperty(this, "close", event => {
        if (event && event.defaultPrevented) return;
        this.setState({
          isOpen: false,
          clientX: 0,
          clientY: 0
        });
        document.removeEventListener('mousedown', this.handleMouseDown);
        document.removeEventListener('keydown', this.handleKeyDown, false);
      });

      _defineProperty(this, "toggle", event => {
        if (this.state.isOpen) {
          this.close(event);
        } else {
          this.open(event);
        }
      });

      _defineProperty(this, "handleScroll", event => {
        event.preventDefault();
      });

      _defineProperty(this, "handleMouseDown", event => {
        const target = event.target;
        const isOpen = this.state.isOpen; // NOTE: Flow doesn't yet have a definition for `SVGElement`
        // $FlowFixMe

        if (!(target instanceof HTMLElement) && !(target instanceof SVGElement)) {
          return;
        } // NOTE: Why not use the <Blanket /> component to close?
        // We don't want to interupt the user's flow. Taking this approach allows
        // user to click "through" to other elements and close the popout.


        if (isOpen && !this.contentNode.contains(target) && !this.targetNode.contains(target)) {
          this.close(event);
        }
      });

      _defineProperty(this, "handleKeyDown", event => {
        const key = event.key;

        if (key === 'Escape') {
          this.close(event);
        }
      });

      _defineProperty(this, "getTarget", ref => {
        this.targetNode = ref;
      });

      _defineProperty(this, "getContent", ref => {
        this.contentNode = ref;
      });
    }

    render() {
      const _this$props = this.props,
            mode = _this$props.mode,
            onClose = _this$props.onClose,
            onOpen = _this$props.onOpen,
            target = _this$props.target;
      const _this$state = this.state,
            clientX = _this$state.clientX,
            clientY = _this$state.clientY,
            isOpen = _this$state.isOpen;
      return React.createElement(Fragment, null, React.createElement(Target, {
        targetRef: this.getTarget,
        target: target,
        mode: mode,
        isOpen: isOpen,
        toggle: this.toggle,
        open: this.open
      }), isOpen ? React.createElement(ScrollLock, null) : null, React.createElement(TransitionProvider, {
        isOpen: isOpen,
        onEntered: onOpen,
        onExited: onClose
      }, transitionState => React.createElement(WrappedComponent, _extends({
        close: this.close,
        open: this.open,
        getModalRef: this.getContent,
        targetNode: this.targetNode,
        contentNode: this.contentNode,
        isOpen: isOpen,
        mouseCoords: {
          clientX,
          clientY
        },
        style: transition(transitionState)
      }, this.props))));
    }

  }

  _defineProperty(IntermediateComponent, "defaultProps", {
    mode: 'click',
    onClose: NOOP,
    onOpen: NOOP
  });

  IntermediateComponent.displayName = getDisplayName(WrappedComponent);
  return IntermediateComponent;
}

// Generate a unique enough ID
function generateUEID() {
  let first = Math.random() * 46656 | 0;
  let second = Math.random() * 46656 | 0;
  first = ('000' + first.toString(36)).slice(-3);
  second = ('000' + second.toString(36)).slice(-3);
  return first + second;
}

export { generateUEID, fade, slideUp, slideDown, slideInHorizontal, springDown, zoomInDown, TransitionProvider, withTransitionState, Blanket, withModalHandlers };
