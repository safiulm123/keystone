'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/objectWithoutProperties'));
var core = require('@emotion/core');
var _objectSpread = _interopDefault(require('@babel/runtime/helpers/objectSpread'));
var common = require('@arch-ui/common');
var theme = require('@arch-ui/theme');

// ------------------------------

const HiddenInput = (_ref) => {
  let innerRef = _ref.innerRef,
      props = _objectWithoutProperties(_ref, ["innerRef"]);

  return core.jsx("input", _extends({
    ref: innerRef,
    tabIndex: "-1",
    css: {
      border: 0,
      clip: 'rect(1px, 1px, 1px, 1px)',
      height: 1,
      margin: 0,
      opacity: 0,
      overflow: 'hidden',
      padding: 0,
      position: 'absolute',
      whiteSpace: 'nowrap',
      width: 1
    }
  }, props));
};

// ==============================

/*
 *  Why?
 *  ------------------------------
 *  For a while now browsers have been ignoring the `autocomplete="off"`
 *  property on form and input elements:
 *  - https://bugs.chromium.org/p/chromium/issues/detail?id=468153#c164
 *
 *  How?
 *  ------------------------------
 *  Browsers will autocomplete inputs in the order they're encountered; this
 *  component will capture the browser's attempt to autocomplete into these
 *  two hidden inputs and leave your legitimate fields unpolluted.
 *
 *  NOTE
 *  ------------------------------
 *  This component *must* be rendered before your legitimate fields.
 */

const AutocompleteCaptor = React.memo(function AutocompleteCaptor() {
  return React__default.createElement(React.Fragment, null, React__default.createElement(HiddenInput, {
    autoComplete: "username",
    type: "text",
    tabIndex: -1
  }), React__default.createElement(HiddenInput, {
    autoComplete: "email",
    type: "text",
    tabIndex: -1
  }), React__default.createElement(HiddenInput, {
    autoComplete: "current-password",
    type: "password",
    tabIndex: -1
  }), React__default.createElement(HiddenInput, {
    autoComplete: "new-password",
    type: "password",
    tabIndex: -1
  }));
}, () => true);

// Basic Input
// ------------------------------

const inputStyles = function inputStyles() {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread({}, common.uniformHeight, {
    backgroundColor: props.disabled ? theme.colors.N10 : 'white',
    borderColor: theme.colors.N20,
    color: 'inherit',
    width: '100%',
    ':hover': {
      borderColor: theme.colors.N30,
      outline: 0
    },
    ':focus': {
      borderColor: theme.colors.primary,
      outline: 0
    },
    '&[disabled]': {
      borderColor: theme.colors.N15,
      backgroundColor: theme.colors.N05
    }
  }, props.isMultiline ? {
    lineHeight: 'inherit',
    minHeight: 100,
    resize: 'vertical',
    whiteSpace: 'wrap'
  } : undefined);
};
const Input = React.forwardRef((props, ref) => {
  const isMultiline = props.isMultiline,
        inputProps = _objectWithoutProperties(props, ["isMultiline"]);

  const Component = isMultiline ? 'textarea' : 'input';
  return core.jsx(Component, _extends({
    ref: ref,
    css: inputStyles(props)
  }, inputProps));
});

exports.AutocompleteCaptor = AutocompleteCaptor;
exports.HiddenInput = HiddenInput;
exports.Input = Input;
exports.inputStyles = inputStyles;
