"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), _objectSpread = _interopDefault(require("@babel/runtime/helpers/objectSpread")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), react = require("react"), reactRouterDom = require("react-router-dom"), reactDom = require("react-dom"), styled = _interopDefault(require("@emotion/styled")), core = require("@emotion/core"), theme = require("@arch-ui/theme"), reactFocusMarshal = require("react-focus-marshal"), modalUtils = require("@arch-ui/modal-utils");

const ItemElement = props => props.to ? core.jsx(reactRouterDom.Link, props) : props.href ? core.jsx("a", props) : core.jsx("button", _extends({
  type: "button"
}, props)), ItemInner = _ref => {
  let children = _ref.children, icon = _ref.icon;
  return icon ? core.jsx("div", {
    css: {
      alignItems: "center",
      display: "flex",
      lineHeight: 1
    }
  }, core.jsx("div", {
    key: "icon",
    css: {
      marginRight: theme.gridSize,
      width: 16,
      textAlign: "center"
    }
  }, icon), core.jsx("div", {
    key: "children",
    css: {
      flex: 1
    }
  }, children)) : children;
}, Item = _ref2 => {
  let children = _ref2.children, icon = _ref2.icon, isDisabled = _ref2.isDisabled, props = _objectWithoutProperties(_ref2, [ "children", "icon", "isDisabled" ]);
  return core.jsx(ItemElement, _extends({
    disabled: isDisabled,
    css: {
      appearance: "none",
      background: "none",
      border: "1px solid transparent",
      boxSizing: "border-box",
      color: isDisabled ? theme.colors.N40 : theme.colors.text,
      cursor: "pointer",
      display: "block",
      fontSize: 14,
      lineHeight: "17px",
      margin: 0,
      padding: "".concat(theme.gridSize, "px ").concat(1.5 * theme.gridSize, "px"),
      pointerEvents: isDisabled ? "none" : null,
      textAlign: "left",
      transition: "box-shadow 100ms linear",
      verticalAlign: "middle",
      whiteSpace: "nowrap",
      width: "100%",
      "&:hover, &:focus": {
        backgroundColor: theme.colors.B.L90,
        color: theme.colors.primary,
        outline: 0,
        textDecoration: "none"
      }
    }
  }, props), core.jsx(ItemInner, {
    icon: icon
  }, children));
}, Menu = styled.div(_ref3 => {
  const placementStyles = {
    left: _ref3.left,
    top: _ref3.top
  };
  return _objectSpread({
    backgroundColor: "white",
    borderRadius: theme.borderRadius,
    boxShadow: theme.shadows[2],
    marginTop: theme.gridSize,
    minWidth: 160,
    paddingBottom: theme.gridSize / 2,
    paddingTop: theme.gridSize / 2,
    position: "absolute",
    zIndex: 2
  }, placementStyles);
});

function focus(el) {
  el && el instanceof HTMLElement && "function" == typeof el.focus && el.focus();
}

class Dropdown extends react.Component {
  constructor() {
    super(...arguments), _defineProperty(this, "menu", void 0), _defineProperty(this, "lastHover", void 0), 
    _defineProperty(this, "state", {
      leftOffset: 0,
      topOffset: 0
    }), _defineProperty(this, "handleItemClick", _ref4 => {
      let onClick = _ref4.onClick, data = _objectWithoutProperties(_ref4, [ "onClick" ]);
      return event => {
        const _this$props = this.props, close = _this$props.close;
        _this$props.selectClosesMenu && close(event), onClick && onClick({
          event: event,
          data: data
        });
      };
    }), _defineProperty(this, "handleKeyDown", event => {
      const key = event.key, target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (-1 === [ "ArrowUp", "ArrowDown", "PageUp", "PageDown" ].indexOf(key)) return;
      event.preventDefault();
      const isArrowUp = "ArrowUp" === key, isArrowDown = "ArrowDown" === key, isPageUp = "PageUp" === key, isPageDown = "PageDown" === key, firstItem = this.menu.firstChild, lastItem = this.menu.lastChild, previousItem = target.previousSibling, nextItem = target.nextSibling;
      isArrowUp && focus(previousItem), isArrowDown && focus(nextItem), isPageUp && focus(firstItem), 
      isPageDown && focus(lastItem), target === firstItem && isArrowUp && focus(lastItem), 
      target === lastItem && isArrowDown && focus(firstItem);
    }), _defineProperty(this, "handleMouseEnter", _ref5 => {
      let target = _ref5.target;
      target instanceof HTMLElement && (this.lastHover = target), document.activeElement && document.activeElement.blur();
    }), _defineProperty(this, "handleMenuLeave", () => {
      focus(this.lastHover);
    }), _defineProperty(this, "getMenu", ref => {
      null !== ref && (this.menu = ref, this.props.getModalRef(ref));
    }), _defineProperty(this, "calculatePosition", () => {
      const _this$props2 = this.props, align = _this$props2.align, mode = _this$props2.mode, mouseCoords = _this$props2.mouseCoords, targetNode = _this$props2.targetNode;
      if (!targetNode || !document.body) return;
      const bodyRect = document.body.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), menuHeight = this.menu.clientHeight, menuWidth = this.menu.clientWidth;
      let leftOffset = 0, topOffset = 0;
      if ("click" === mode) return leftOffset = "left" === align ? targetRect.left : targetRect.right - menuWidth, 
      topOffset = targetRect.bottom - bodyRect.top, void this.setState({
        leftOffset: leftOffset,
        topOffset: topOffset
      });
      const clientX = mouseCoords.clientX, clientY = mouseCoords.clientY, right = window.innerWidth - clientX > menuWidth, top = window.innerHeight - clientY > menuHeight, bottom = !top;
      right && (leftOffset = clientX), !right && (leftOffset = clientX - menuWidth), top && (topOffset = clientY - bodyRect.top), 
      bottom && (topOffset = clientY - bodyRect.top - menuHeight), this.setState({
        leftOffset: leftOffset,
        topOffset: topOffset
      });
    });
  }
  componentDidMount() {
    this.calculatePosition(), document.addEventListener("keydown", this.handleKeyDown, !1);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown, !1);
  }
  render() {
    const _this$props3 = this.props, items = _this$props3.items, style = _this$props3.style, _this$state = this.state, leftOffset = _this$state.leftOffset, topOffset = _this$state.topOffset, attachTo = document.body;
    return attachTo ? reactDom.createPortal(core.jsx(reactFocusMarshal.FocusTrap, {
      options: {
        clickOutsideDeactivates: !0
      }
    }, core.jsx(Menu, {
      left: leftOffset,
      onMouseLeave: this.handleMenuLeave,
      ref: this.getMenu,
      style: style,
      top: topOffset
    }, items.map((item, idx) => {
      const content = item.content, rest = _objectWithoutProperties(item, [ "content" ]);
      return core.jsx(Item, _extends({}, rest, {
        onClick: this.handleItemClick(item),
        onMouseEnter: this.handleMouseEnter,
        key: idx
      }), content);
    }))), attachTo) : null;
  }
}

_defineProperty(Dropdown, "defaultProps", {
  align: "left",
  selectClosesMenu: !0
});

var index = modalUtils.withModalHandlers(Dropdown, {
  transition: modalUtils.slideDown
});

exports.default = index;
