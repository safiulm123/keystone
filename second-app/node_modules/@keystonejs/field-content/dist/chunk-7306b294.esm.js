import '@babel/runtime/helpers/esm/objectWithoutProperties';
import '@babel/runtime/helpers/esm/extends';
import '@emotion/core';
import { a as hasAncestorBlock, b as hasBlock } from './chunk-6fbba733.esm.js';
import { ListUnorderedIcon } from '@arch-ui/icons';
import '@arch-ui/theme';
import '@arch-ui/color-utils';
import '@arch-ui/tooltip';
import '@arch-ui/typography';
import { a as ToolbarButton } from './chunk-2eef5f01.esm.js';
import { createElement } from 'react';
import { type } from './chunk-302bcd6d.esm.js';
import { type as type$1 } from './chunk-d6baba6d.esm.js';

let handleListButtonClick = (editor, editorState, type$$1) => {
  let isListItem = hasBlock(editorState, type$1);
  let isOrderedList = hasAncestorBlock(editorState, type$$1);
  let otherListType = type$$1 === 'ordered-list' ? 'unordered-list' : 'ordered-list';

  if (isListItem && isOrderedList) {
    editor.setBlocks(type);
    editor.unwrapBlock(type$$1);
  } else if (isListItem) {
    editor.unwrapBlock(otherListType);
    editor.wrapBlock(type$$1);
  } else {
    editor.setBlocks(type$1).wrapBlock(type$$1);
  }

  editor.focus();
};

let type$2 = 'unordered-list';

function ToolbarElement(_ref) {
  let {
    editor,
    editorState
  } = _ref;
  return createElement(ToolbarButton, {
    label: "Unordered List",
    icon: createElement(ListUnorderedIcon, null),
    isActive: hasAncestorBlock(editorState, type$2),
    onClick: () => {
      handleListButtonClick(editor, editorState, type$2);
    }
  });
}

let getPlugins = () => [{
  onKeyDown(event, editor, next) {
    // make it so when you press enter in an empty list item,
    // the block type will change to a paragraph
    if (event.keyCode === 13 && hasAncestorBlock(editor.value, type$2) && editor.value.focusText.text === '') {
      editor.setBlocks(type).unwrapBlock(type$2);
      return;
    }

    next();
  }

}];

function Node(_ref2) {
  let {
    attributes,
    children
  } = _ref2;
  return createElement("ul", attributes, children);
}

const getSchema = () => ({
  nodes: [{
    match: {
      type: type$1
    },
    min: 0
  }],

  normalize(editor, error) {
    switch (error.code) {
      case 'child_type_invalid':
        {
          editor.unwrapBlockByKey(error.node.key, type$2);
          return;
        }
    }
  }

});

export { type$2 as type, ToolbarElement, getPlugins, Node, getSchema };
